
Fatbin elf code:
================
arch = sm_86
code version = [1,7]
host = linux
compile_size = 64bit

Fatbin elf code:
================
arch = sm_86
code version = [1,7]
host = linux
compile_size = 64bit

Fatbin ptx code:
================
arch = sm_86
code version = [8,1]
host = linux
compile_size = 64bit
compressed








.version 8.1
.target sm_86
.address_size 64




.visible .entry _Z4funcPfS_S_(
.param .u64 _Z4funcPfS_S__param_0,
.param .u64 _Z4funcPfS_S__param_1,
.param .u64 _Z4funcPfS_S__param_2
)
{
.reg .b32 %r<35>;
.reg .b64 %rd<5>;

	.shared .align 4 .b8 _ZZ4funcPfS_S_E6B_part[16384];

ld.param.u64 %rd1, [_Z4funcPfS_S__param_1];
cvta.to.global.u64 %rd2, %rd1;				// rd2 for B addr
mov.u32 %r1, %tid.x;
mov.u32 %r2, %ctaid.x;

shl.b32 %r3, %r1, 2;						// r3 = tix << 2
shr.s32 %r4, %r3, 31;
shr.u32 %r5, %r4, 25;
add.s32 %r6, %r3, %r5;						// r6 = f(tix << 2) f表示操作过的
shr.s32 %r7, %r6, 7;						// r7 = B_y(-ldg_cnt)
shl.b32 %r8, %r2, 7;						// bix * SMEM_Y
and.b32 %r9, %r6, -128;
sub.s32 %r10, %r3, %r9;						// r9 = r3 - 128
add.s32 %r11, %r10, %r8;					// r11 = B_ldg_x = r8+ () % SMEM_Y
shl.b32 %r12, %r7, 9;						// B_sts_y * 128 * 4
mov.u32 %r13, _ZZ4funcPfS_S_E6B_part;		// r13 for B_part addr
add.s32 %r14, %r13, %r12;					// B + B_sts_y
shl.b32 %r15, %r10, 2;						// r10 = B_sts_x * 4
add.s32 %r16, %r14, %r15;					// r16 for B_part[][][] addr
shl.b32 %r17, %r7, 8;						// r17 = B_ldg_y * N
add.s32 %r18, %r11, %r17;					// r18 = r17 + B_ldg_x
mul.wide.s32 %rd3, %r18, 4;					// rd3 for (B_y*N+B_ldg_x)*4
add.s64 %rd4, %rd2, %rd3;					// rd4 for B[] addr

ld.global.nc.v4.u32 {%r19, %r20, %r21, %r22}, [%rd4];
st.shared.v4.u32 [%r16], {%r19, %r20, %r21, %r22};
ld.global.nc.v4.u32 {%r27, %r28, %r29, %r30}, [%rd4+8192];
st.shared.v4.u32 [%r16+4096], {%r27, %r28, %r29, %r30};

bar.sync 0;
ret;

}


/*
int B_ldg_y_stride = BLOCK_XY * 4 / SMEM_Y;     // 8
#pragma unroll
for(int ldg_cnt = 0; ldg_cnt < SMEM_X; ldg_cnt += B_ldg_y_stride){
	int B_ldg_y = ldg_cnt + (tix << 2) / SMEM_Y;
	int B_ldg_x = bix * SMEM_Y + (tix << 2) % SMEM_Y;
	int B_sts_y = ldg_cnt + (tix << 2) / SMEM_Y;
	int B_sts_x = (tix << 2) % SMEM_Y;
	FETCH_FLOAT4(B_part[0][B_sts_y][B_sts_x]) = FETCH_FLOAT4(B[B_ldg_y * N + B_ldg_x]);
}

__syncthreads();
*/